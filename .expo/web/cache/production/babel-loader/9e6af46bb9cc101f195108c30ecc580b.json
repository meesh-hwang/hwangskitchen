{"ast":null,"code":"import _extends from\"@babel/runtime/helpers/extends\";import interpolateNode from\"../reanimated1/derived/interpolate\";export var Extrapolation;(function(Extrapolation){Extrapolation[\"IDENTITY\"]=\"identity\";Extrapolation[\"CLAMP\"]=\"clamp\";Extrapolation[\"EXTEND\"]=\"extend\";})(Extrapolation||(Extrapolation={}));function isNode(x){'worklet';return x.__nodeId!==undefined;}function getVal(type,coef,val,leftEdgeOutput,rightEdgeOutput,x){'worklet';switch(type){case Extrapolation.IDENTITY:return x;case Extrapolation.CLAMP:if(coef*val<coef*leftEdgeOutput){return leftEdgeOutput;}return rightEdgeOutput;case Extrapolation.EXTEND:default:return val;}}function isExtrapolate(value){'worklet';return value===Extrapolation.EXTEND||value===Extrapolation.CLAMP||value===Extrapolation.IDENTITY;}function validateType(type){'worklet';var extrapolationConfig={extrapolateLeft:Extrapolation.EXTEND,extrapolateRight:Extrapolation.EXTEND};if(!type){return extrapolationConfig;}if(typeof type==='string'){if(!isExtrapolate(type)){throw new Error(\"Reanimated: not supported value for \\\"interpolate\\\" \\nSupported values: [\\\"extend\\\", \\\"clamp\\\", \\\"identity\\\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\\n        interpolate(value, [inputRange], [outputRange], \\\"clamp\\\")\");}extrapolationConfig.extrapolateLeft=type;extrapolationConfig.extrapolateRight=type;return extrapolationConfig;}if(type.extrapolateLeft&&!isExtrapolate(type.extrapolateLeft)||type.extrapolateRight&&!isExtrapolate(type.extrapolateRight)){throw new Error(\"Reanimated: not supported value for \\\"interpolate\\\" \\nSupported values: [\\\"extend\\\", \\\"clamp\\\", \\\"identity\\\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\\n      interpolate(value, [inputRange], [outputRange], {\\n        extrapolateLeft: Extrapolation.CLAMP,\\n        extrapolateRight: Extrapolation.IDENTITY\\n      }})\");}_extends(extrapolationConfig,type);return extrapolationConfig;}function internalInterpolate(x,narrowedInput,extrapolationConfig){'worklet';var leftEdgeInput=narrowedInput.leftEdgeInput,rightEdgeInput=narrowedInput.rightEdgeInput,leftEdgeOutput=narrowedInput.leftEdgeOutput,rightEdgeOutput=narrowedInput.rightEdgeOutput;if(rightEdgeInput-leftEdgeInput===0)return leftEdgeOutput;var progress=(x-leftEdgeInput)/(rightEdgeInput-leftEdgeInput);var val=leftEdgeOutput+progress*(rightEdgeOutput-leftEdgeOutput);var coef=rightEdgeOutput>=leftEdgeOutput?1:-1;if(coef*val<coef*leftEdgeOutput){return getVal(extrapolationConfig.extrapolateLeft,coef,val,leftEdgeOutput,rightEdgeOutput,x);}else if(coef*val>coef*rightEdgeOutput){return getVal(extrapolationConfig.extrapolateRight,coef,val,leftEdgeOutput,rightEdgeOutput,x);}return val;}export function interpolate(x,input,output,type){'worklet';if(input.length<2||output.length<2){throw Error('Interpolation input and output should contain at least two values.');}var extrapolationConfig=validateType(type);if(isNode(x)){console.warn(\"interpolate() was renamed to interpolateNode() in Reanimated 2. Please use interpolateNode() instead\");return interpolateNode(x,{inputRange:input,outputRange:output,extrapolateLeft:extrapolationConfig.extrapolateLeft,extrapolateRight:extrapolationConfig.extrapolateRight});}var length=input.length;var narrowedInput={leftEdgeInput:input[0],rightEdgeInput:input[1],leftEdgeOutput:output[0],rightEdgeOutput:output[1]};if(length>2){if(x>input[length-1]){narrowedInput.leftEdgeInput=input[length-2];narrowedInput.rightEdgeInput=input[length-1];narrowedInput.leftEdgeOutput=output[length-2];narrowedInput.rightEdgeOutput=output[length-1];}else{for(var i=1;i<length;++i){if(x<=input[i]){narrowedInput.leftEdgeInput=input[i-1];narrowedInput.rightEdgeInput=input[i];narrowedInput.leftEdgeOutput=output[i-1];narrowedInput.rightEdgeOutput=output[i];break;}}}}return internalInterpolate(x,narrowedInput,extrapolationConfig);}","map":{"version":3,"sources":["C:/Users/miche/Desktop/hwangskitchen/node_modules/react-native-reanimated/lib/reanimated2/interpolation.js"],"names":["interpolateNode","Extrapolation","isNode","x","__nodeId","undefined","getVal","type","coef","val","leftEdgeOutput","rightEdgeOutput","IDENTITY","CLAMP","EXTEND","isExtrapolate","value","validateType","extrapolationConfig","extrapolateLeft","extrapolateRight","Error","internalInterpolate","narrowedInput","leftEdgeInput","rightEdgeInput","progress","interpolate","input","output","length","console","warn","inputRange","outputRange","i"],"mappings":"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","sourcesContent":["// @ts-ignore JS file\nimport interpolateNode from '../reanimated1/derived/interpolate';\nexport var Extrapolation;\n(function (Extrapolation) {\n    Extrapolation[\"IDENTITY\"] = \"identity\";\n    Extrapolation[\"CLAMP\"] = \"clamp\";\n    Extrapolation[\"EXTEND\"] = \"extend\";\n})(Extrapolation || (Extrapolation = {}));\nfunction isNode(x) {\n    'worklet';\n    return x.__nodeId !== undefined;\n}\nfunction getVal(type, coef, val, leftEdgeOutput, rightEdgeOutput, x) {\n    'worklet';\n    switch (type) {\n        case Extrapolation.IDENTITY:\n            return x;\n        case Extrapolation.CLAMP:\n            if (coef * val < coef * leftEdgeOutput) {\n                return leftEdgeOutput;\n            }\n            return rightEdgeOutput;\n        case Extrapolation.EXTEND:\n        default:\n            return val;\n    }\n}\nfunction isExtrapolate(value) {\n    'worklet';\n    return (value === Extrapolation.EXTEND ||\n        value === Extrapolation.CLAMP ||\n        value === Extrapolation.IDENTITY);\n}\n// validates extrapolations type\n// if type is correct, converts it to ExtrapolationConfig\nfunction validateType(type) {\n    'worklet';\n    // initialize extrapolationConfig with default extrapolation\n    const extrapolationConfig = {\n        extrapolateLeft: Extrapolation.EXTEND,\n        extrapolateRight: Extrapolation.EXTEND,\n    };\n    if (!type) {\n        return extrapolationConfig;\n    }\n    if (typeof type === 'string') {\n        if (!isExtrapolate(type)) {\n            throw new Error(`Reanimated: not supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n        interpolate(value, [inputRange], [outputRange], \"clamp\")`);\n        }\n        extrapolationConfig.extrapolateLeft = type;\n        extrapolationConfig.extrapolateRight = type;\n        return extrapolationConfig;\n    }\n    // otherwise type is extrapolation config object\n    if ((type.extrapolateLeft && !isExtrapolate(type.extrapolateLeft)) ||\n        (type.extrapolateRight && !isExtrapolate(type.extrapolateRight))) {\n        throw new Error(`Reanimated: not supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n      interpolate(value, [inputRange], [outputRange], {\n        extrapolateLeft: Extrapolation.CLAMP,\n        extrapolateRight: Extrapolation.IDENTITY\n      }})`);\n    }\n    Object.assign(extrapolationConfig, type);\n    return extrapolationConfig;\n}\nfunction internalInterpolate(x, narrowedInput, extrapolationConfig) {\n    'worklet';\n    const { leftEdgeInput, rightEdgeInput, leftEdgeOutput, rightEdgeOutput, } = narrowedInput;\n    if (rightEdgeInput - leftEdgeInput === 0)\n        return leftEdgeOutput;\n    const progress = (x - leftEdgeInput) / (rightEdgeInput - leftEdgeInput);\n    const val = leftEdgeOutput + progress * (rightEdgeOutput - leftEdgeOutput);\n    const coef = rightEdgeOutput >= leftEdgeOutput ? 1 : -1;\n    if (coef * val < coef * leftEdgeOutput) {\n        return getVal(extrapolationConfig.extrapolateLeft, coef, val, leftEdgeOutput, rightEdgeOutput, x);\n    }\n    else if (coef * val > coef * rightEdgeOutput) {\n        return getVal(extrapolationConfig.extrapolateRight, coef, val, leftEdgeOutput, rightEdgeOutput, x);\n    }\n    return val;\n}\n// TODO: support default values in worklets:\n// e.g. function interpolate(x, input, output, type = Extrapolatation.CLAMP)\nexport function interpolate(x, input, output, type) {\n    'worklet';\n    if (input.length < 2 || output.length < 2) {\n        throw Error('Interpolation input and output should contain at least two values.');\n    }\n    const extrapolationConfig = validateType(type);\n    if (isNode(x)) {\n        console.warn(`interpolate() was renamed to interpolateNode() in Reanimated 2. Please use interpolateNode() instead`);\n        return interpolateNode(x, {\n            inputRange: input,\n            outputRange: output,\n            extrapolateLeft: extrapolationConfig.extrapolateLeft,\n            extrapolateRight: extrapolationConfig.extrapolateRight,\n        });\n    }\n    const length = input.length;\n    const narrowedInput = {\n        leftEdgeInput: input[0],\n        rightEdgeInput: input[1],\n        leftEdgeOutput: output[0],\n        rightEdgeOutput: output[1],\n    };\n    if (length > 2) {\n        if (x > input[length - 1]) {\n            narrowedInput.leftEdgeInput = input[length - 2];\n            narrowedInput.rightEdgeInput = input[length - 1];\n            narrowedInput.leftEdgeOutput = output[length - 2];\n            narrowedInput.rightEdgeOutput = output[length - 1];\n        }\n        else {\n            for (let i = 1; i < length; ++i) {\n                if (x <= input[i]) {\n                    narrowedInput.leftEdgeInput = input[i - 1];\n                    narrowedInput.rightEdgeInput = input[i];\n                    narrowedInput.leftEdgeOutput = output[i - 1];\n                    narrowedInput.rightEdgeOutput = output[i];\n                    break;\n                }\n            }\n        }\n    }\n    return internalInterpolate(x, narrowedInput, extrapolationConfig);\n}\n"]},"metadata":{},"sourceType":"module"}